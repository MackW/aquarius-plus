#include "common.cb"

// Playfield dimensions
const int PLAYFIELD_W  = 10;
const int PLAYFIELD_H  = 20;
const int PLAYFIELD_YT = 2;
const int PLAYFIELD_YB = (PLAYFIELD_YT + PLAYFIELD_H - 1);
const int PLAYFIELD_XL = 11;
const int PLAYFIELD_XR = (PLAYFIELD_XL + PLAYFIELD_W - 1);

const int MARKER_TILE      = 1;
const int DELAY_LEFT_RIGHT = 5;
const int DELAY_DOWN       = 3;

// Tetrominoes enum
const int TM_I     = 0;
const int TM_J     = 1;
const int TM_L     = 2;
const int TM_O     = 3;
const int TM_S     = 4;
const int TM_T     = 5;
const int TM_Z     = 6;
const int TM_TOTAL = 7;

// Tile data
extern char tile_palette[];
extern char tile_data[];
extern char tile_data_end[];

// VRAM pointers
const int  *vram_tilemap  = 0xC000;
const char *vram_tiledata = 0xE000;

// Game statistics
int  score;
char level;
int  lines;
char gameover;
char quit;

// Background animation variables
char *bgtiles_dst;
char *bgtiles_src;
char *bgtiles_src2;
char  bgtiles_idx = 0;
char  bgdelay     = 0;

// Current tetromino variables
char cur_tetromino;
char cur_rot;
char cur_posx;
char cur_posy;

// Current background tile
char bg_tile = 13;

// Pressed keys array
char pressed_keys[8];

// Next tetromino (shown in preview area)
char next_tetromino;

// Random selection for next tetromino
char tetromino_random = 0;

// Temporary string variables for drawing stats
char tmpstr[16];
char tmpstr2[16];

// Level speed curve (number of frames delay per gravity drop)
char speed_curve[21] = {52, 48, 44, 40, 36, 32, 27, 21, 16, 10, 9, 8, 7, 6, 5, 5, 4, 4, 3, 3, 2};

// Keyboard bitmap
const int KBM_LEFT       = (1 << 0);
const int KBM_RIGHT      = (1 << 1);
const int KBM_UP         = (1 << 2);
const int KBM_DOWN       = (1 << 3);
const int KBM_ROTATE_CCW = (1 << 4);
const int KBM_ROTATE_CW  = (1 << 5);

// clang-format off
// Tetromino I shape in 4 rotations
char tetromino_i[4 * 16] = {
    // Rotation 0
     0,  0,  0,  0,
    16, 17, 17, 18,
     0,  0,  0,  0,
     0,  0,  0,  0,
    // Rotation 1
     0,  0, 19,  0,
     0,  0, 20,  0,
     0,  0, 20,  0,
     0,  0, 21,  0,
    // Rotation 2
     0,  0,  0,  0,
     0,  0,  0,  0,
    16, 17, 17, 18,
     0,  0,  0,  0,
    // Rotation 3
     0, 19,  0,  0,
     0, 20,  0,  0,
     0, 20,  0,  0,
     0, 21,  0,  0
};

// Tetromino J shape in 4 rotations
char tetromino_j[4 * 9] = {
    // Rotation 0
    25,  0,  0,
    25, 25, 25,
     0,  0,  0,
    // Rotation 1
     0, 25, 25,
     0, 25,  0,
     0, 25,  0,
    // Rotation 2
     0,  0,  0,
    25, 25, 25,
     0,  0, 25,
    // Rotation 3
     0, 25,  0,
     0, 25,  0,
    25, 25,  0
};

// Tetromino L shape in 4 rotations
char tetromino_l[4 * 9] = {
    // Rotation 0
     0,  0, 26,
    26, 26, 26,
     0,  0,  0,
    // Rotation 1
     0, 26,  0,
     0, 26,  0,
     0, 26, 26,
    // Rotation 2
     0,  0,  0,
    26, 26, 26,
    26,  0,  0,
    // Rotation 3
    26, 26,  0,
     0, 26,  0,
     0, 26,  0
};

// Tetromino O shape (just 1 rotation)
char tetromino_o[4] = {
    27, 27,
    27, 27
};

// Tetromino S shape in 4 rotations
char tetromino_s[4 * 9] = {
    // Rotation 0
     0, 24, 24,
    24, 24,  0,
     0,  0,  0,
    // Rotation 1
     0, 24,  0,
     0, 24, 24,
     0,  0, 24,
    // Rotation 2
     0,  0,  0,
     0, 24, 24,
    24, 24,  0,
    // Rotation 3
    24,  0,  0,
    24, 24,  0,
     0, 24,  0
};

// Tetromino T shape in 4 rotations
char tetromino_t[4 * 9] = {
    // Rotation 0
     0, 22,  0,
    22, 22, 22,
     0,  0,  0,
    // Rotation 1
     0, 22,  0,
     0, 22, 22,
     0, 22,  0,
    // Rotation 2
     0,  0,  0,
    22, 22, 22,
     0, 22,  0,
    // Rotation 3
     0, 22,  0,
    22, 22,  0,
     0, 22,  0
};

// Tetromino Z shape in 4 rotations
char tetromino_z[4 * 9] = {
    // Rotation 0
    23, 23,  0,
     0, 23, 23,
     0,  0,  0,
    // Rotation 1
     0,  0, 23,
     0, 23, 23,
     0, 23,  0,
    // Rotation 2
     0,  0,  0,
    23, 23,  0,
     0, 23, 23,
    // Rotation 3
     0, 23,  0,
    23, 23,  0,
    23,  0,  0
};
// clang-format on

video_wait_line(char linenr) {
    IO_VIRQLINE = linenr;
    IO_IRQSTAT  = 2;
    while ((IO_IRQSTAT & 2) == 0) {
    }
}

// Set tile 'tile_idx' at position i,j
set_tile(char i, char j, char tile_idx) {
    vram_tilemap[(j << 6) | i] = 0x1100 | tile_idx;
}

set_tile2(char i, char j, int val) {
    vram_tilemap[(j << 6) | i] = 0x1100 | val;
}

// Get tile at position i,j
get_tile(char i, char j) {
    if (j < PLAYFIELD_YT && (i >= PLAYFIELD_XL && i <= PLAYFIELD_XR))
        return bg_tile;

    return vram_tilemap[(j << 6) | i] & 0xFF;
}

// This function will draw the given tetromino at coordinate i,j. If check is set,
// instead of drawing the function will return if the tetromino can be drawn without
// intersecting with existing blocks (returns 0 on collision).
draw_tetromino(char i, char j, char tetromino, char rot, char check, char lock) {
    rot      = rot & 3;
    char *p  = 0;
    char  sz = 0;

    if (tetromino == TM_O) {
        sz = 2;
        p  = tetromino_o;
    } else if (tetromino == TM_J) {
        sz = 3;
        p  = tetromino_j + 9 * rot;
    } else if (tetromino == TM_L) {
        sz = 3;
        p  = tetromino_l + 9 * rot;
    } else if (tetromino == TM_S) {
        sz = 3;
        p  = tetromino_s + 9 * rot;
    } else if (tetromino == TM_T) {
        sz = 3;
        p  = tetromino_t + 9 * rot;
    } else if (tetromino == TM_Z) {
        sz = 3;
        p  = tetromino_z + 9 * rot;
    } else if (tetromino == TM_I) {
        sz = 4;
        p  = tetromino_i + 16 * rot;
    }

    if (sz == 3 || sz == 4) {
        i = i - 1;
        j = j - 1;
    }

    if (check) {
        char y = 0;
        char x;

        while (y < sz) {
            x = 0;
            while (x < sz) {
                char val = *p;
                p        = p + 1;
                if (val && get_tile(i + x, j + y) != bg_tile)
                    return 0;
                x = x + 1;
            }
            y = y + 1;
        }
        return 1;

    } else {
        char y = 0;
        char x;

        while (y < sz) {
            x = 0;
            while (x < sz) {
                char val = *p;
                p        = p + 1;
                if (val) {
                    char jy = j + y;
                    if (jy < PLAYFIELD_YT) {
                        return 0;
                    }
                    if (lock)
                        val = MARKER_TILE;
                    set_tile(i + x, jy, val);
                }
                x = x + 1;
            }
            y = y + 1;
        }
        return 1;
    }
}

// Draw string 'str' at i,j
draw_text(char i, char j, char *str) {
    while (*str) {
        char val = *str;
        str      = str + 1;
        char idx = 1;

        if (val >= '0' && val <= '9') {
            idx = 64 + (val - '0');
        } else if (val >= 'A' && val <= 'Z') {
            idx = 80 + (val - 'A');
        } else if (val >= 'a' && val <= 'z') {
            idx = 80 + (val - 'a');
        }
        set_tile(i, j, idx);
        i = i + 1;
    }
}

// Draw static part of screen. Only drawn at start
draw_static_screen() {
    char i;
    char j;

    // Draw playfield borders
    j = 0;
    while (j < PLAYFIELD_H) {
        set_tile(PLAYFIELD_XL - 1, j + PLAYFIELD_YT, 32);
        set_tile(PLAYFIELD_XR + 1, j + PLAYFIELD_YT, 32);
        j = j + 1;
    }
    i = 0;
    while (i < PLAYFIELD_W + 2) {
        set_tile(i + PLAYFIELD_W, PLAYFIELD_YB + 1, 33);
        i = i + 1;
    }

    // Draw playfield content
    j = 0;
    while (j < PLAYFIELD_H) {
        i = 0;
        while (i < PLAYFIELD_W) {
            set_tile(i + PLAYFIELD_XL, j + PLAYFIELD_YT, bg_tile);
            i = i + 1;
        }
        j = j + 1;
    }

    // Draw tetromino preview borders
    set_tile(26, 4, 33);
    set_tile(27, 4, 34);
    set_tile(28, 4, 35);
    set_tile(29, 4, 35);
    set_tile(30, 4, 36);
    set_tile(31, 4, 33);

    set_tile(26, 5, 40);
    set_tile(26, 6, 41);
    set_tile(26, 7, 41);
    set_tile(26, 8, 42);

    set_tile(31, 5, 43);
    set_tile(31, 6, 44);
    set_tile(31, 7, 44);
    set_tile(31, 8, 45);

    set_tile(26, 9, 33);
    set_tile(27, 9, 37);
    set_tile(28, 9, 38);
    set_tile(29, 9, 38);
    set_tile(30, 9, 39);
    set_tile(31, 9, 33);

    // Draw texts
    draw_text(24, 2, " MARATHON ");
    draw_text(25, 11, "  SCORE ");
    draw_text(25, 14, "  LEVEL ");
    draw_text(25, 17, "  LINES ");
}

// Draw tetromino preview content
draw_preview() {
    // Draw tetromino preview content
    char j;
    char i;
    j = 0;
    while (j < 4) {
        i = 0;
        while (i < 4) {
            set_tile(i + 27, j + 5, 1);
            i = i + 1;
        }
        j = j + 1;
    }

    char x = 28;
    char y = 7;
    if (next_tetromino == TM_O) {
        y = 6;
    } else if (next_tetromino == TM_I) {
        x = 28;
        y = 6;
    }
    draw_tetromino(x, y, next_tetromino, 0, 0, 0);
}

// Processing that needs to be done at the start of the frame
frame() {
    // Wait for end of frame (line 216)
    video_wait_line(216);

    // // Scan keys
    // kb_scan();

    // Update screen during non-visible part
    if (bgdelay == 0) {
        //     // Animate background by updating 2 tile patterns
        memcpy(bgtiles_dst, bgtiles_src2, 64);
    }
    // set_tetromino_sprites(cur_posx << 3, cur_posy << 3, cur_tetromino, cur_rot);

    // Animate background
    if (bgdelay == 0) {
        bgdelay = 2;

        if (bgtiles_idx == 7) {
            bgtiles_idx  = 0;
            bgtiles_src2 = bgtiles_src;
        } else {
            bgtiles_idx  = bgtiles_idx + 1;
            bgtiles_src2 = bgtiles_src2 + 64;
        }
    } else {
        bgdelay = bgdelay - 1;
    }
}

play_marathon() {
    char prev_keys = 0;

    score    = 0;
    level    = 0;
    lines    = 0;
    gameover = 0;

    char gravity_delay = speed_curve[level];
    char left_delay    = 0;
    char right_delay   = 0;
    char down_delay    = 0;

    cur_tetromino = tetromino_random;

    IO_VCTRL = VCTRL_SPR_EN | VCTRL_MODE_TILE;

    // Initial screen drawing
    draw_static_screen();
    draw_preview();

    // Switch video mode to tile mode
    IO_VCTRL = VCTRL_SPR_EN | VCTRL_MODE_TILE;
    // next_piece();

    char wait_down_release = 0;

    while (!gameover) {
        frame();
    }
}

init() {
    // Map video RAM to 0xC000
    IO_BANK3 = 20;

    // Set tile data palette
    char i = 0;
    while (i < 32) {
        IO_VPALSEL  = 32 + i;
        IO_VPALDATA = tile_palette[i];
        i           = i + 1;
    }
    // Copy tile data into VRAM
    memcpy(vram_tiledata, tile_data, tile_data_end - tile_data);

    // Init video
    IO_VSCRX_L = 0;
    IO_VSCRX_H = 0;
    IO_VSCRY   = 0;

    // Disable all sprites
    i = 0;
    while (i < 64) {
        IO_VSPRSEL  = i;
        IO_VSPRATTR = 0;
        i           = i + 1;
    }

    bgtiles_dst      = vram_tiledata + 32 * 46;
    bgtiles_src      = vram_tiledata + 32 * 48;
    bgtiles_src2     = bgtiles_src;
    tetromino_random = IO_VLINE % 7;

    // Draw background
    char j = 0;
    while (j < 25) {
        i = 0;
        while (i < 40) {
            char idx;
            if ((i ^ j) & 1) {
                idx = 47;
            } else {
                idx = 46;
            }
            set_tile(i, j, idx);
            i = i + 1;
        }
        j = j + 1;
    }
}

main() {
    char iobank3_old = IO_BANK3;

    init();
    while (!quit)
        play_marathon();

    IO_BANK3 = iobank3_old;
    IO_VCTRL = VCTRL_TEXT_EN;
}

// clang-format off
#asm
    include "../tiledata.asm"
    include "../lib/memcpy.asm"
#endasm
    // clang-format on
